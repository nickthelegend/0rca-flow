"use server"

import JSZip from "jszip"

export async function deployAgent(agentId: string, nodes: any[], edges: any[]) {
    try {
        console.log(`\n[0rca-Deployer] Start: ${agentId}`)

        // 1. Generate agent.py
        const agentCode = generateAgentCode(agentId, nodes, edges)
        console.log(`[0rca-Deployer] Generated agent.py (${agentCode.length} chars):`)
        console.log("------------------------------------------")
        console.log(agentCode)
        console.log("------------------------------------------")

        // 2. Create Zip
        const zip = new JSZip()
        zip.file("agent.py", agentCode)

        let requirements = `orca-network-sdk>=1.0.8\npython-dotenv\ncrewai[google-genai]\ncrewai-tools\n`
        const useCryptoComAgent = nodes.some(n => n.type === 'cryptoComAgent');
        const useCrewAI = nodes.some(n => n.type === 'crewaiTool' || n.type === 'toolkit');

        if (useCryptoComAgent) {
            requirements += `crypto-com-agent-client\n`
        }
        // crewai is now included by default as it's a dependency of the base OrcaAgent SDK imports

        zip.file("requirements.txt", requirements)
        zip.file(".env", "# Generated by 0rca-flow\n")
        zip.file("Procfile", "web: python agent.py\n")

        const zipBlob = await zip.generateAsync({ type: "uint8array" })
        console.log(`[0rca-Deployer] Zip bundle created: ${(zipBlob.length / 1024).toFixed(2)} KB`)

        // 3. Prepare Deployment
        const DEPLOYER_URL = "https://deploy.0rca.live/deploy"
        const DEPLOYER_TOKEN = process.env.DEPLOYER_SERVICE_TOKEN || "orca_test_token_12345"

        const formData = new FormData()
        const file = new Blob([zipBlob as any], { type: 'application/zip' })
        formData.append('file', file, 'agent.zip')
        formData.append('agentId', agentId)

        const envVars = extractEnvVars(nodes)
        formData.append('envVars', JSON.stringify(envVars))

        console.log(`[0rca-Deployer] Protocol: POST ${DEPLOYER_URL}`)
        console.log(`[0rca-Deployer] Payload: ${envVars.length} Environment Variables`)
        envVars.forEach(v => {
            const masked = v.value ? (v.value.slice(0, 6) + "..." + v.value.slice(-4)) : "empty"
            console.log(`   - ${v.key}: ${masked}`)
        })

        const response = await fetch(DEPLOYER_URL, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${DEPLOYER_TOKEN}`
            },
            body: formData
        })

        console.log(`[0rca-Deployer] Response Status: ${response.status} ${response.statusText}`)

        if (!response.ok) {
            const errorText = await response.text()
            console.error(`[0rca-Deployer] Error Body:`, errorText)
            throw new Error(`Deployer error: ${errorText}`)
        }

        const result = await response.json()
        console.log(`[0rca-Deployer] Success:`, result)
        return { success: true, ...result }

    } catch (error: any) {
        console.error("[0rca-Deployer] Critical Failure:", error.message)
        return { success: false, error: error.message }
    }
}

function generateAgentCode(agentId: string, nodes: any[], edges: any[]) {
    const coreNode = nodes.find(n => n.type === 'agentCore' || n.type === 'cryptoComAgent')
    const modelNode = nodes.find(n => n.type === 'intelligenceModel')
    const walletNode = nodes.find(n => n.type === 'wallet')
    const mcpNodes = nodes.filter(n => n.type === 'mcpServer')
    const systemPromptNode = nodes.find(n => n.type === 'systemPrompt')

    const name = coreNode?.data?.name || agentId
    let model = modelNode?.data?.model || "gemini-2.0-flash"
    const provider = modelNode?.data?.provider || "google"

    // Ensure the model string has a provider prefix if it doesn't already
    if (!model.includes('/') && provider === 'google') {
        model = `google/${model}`
    } else if (!model.includes('/') && provider === 'openai') {
        model = `openai/${model}`
    } else if (model === "gemini-2.0-flash") {
        model = "gemini/gemini-2.0-flash"
    }

    const systemPrompt = systemPromptNode?.data?.content || "You are a helpful AI assistant."
    const vaultAddress = walletNode?.data?.address || ""

    // Determine if we need the CryptoComAgent based on the NODE TYPE
    const useCryptoComAgent = coreNode?.type === 'cryptoComAgent';

    // Extract API Key from UI nodes
    const apiKeyFromUI = modelNode?.data?.apiKey || nodes.find(n => n.type === 'textModel')?.data?.apiKey || ""

    let code = `import os
import sys
from dotenv import load_dotenv\n`

    if (useCryptoComAgent) {
        code += `from orca_agent_sdk import CryptoComAgent\n`
    } else {
        code += `from orca_agent_sdk.agent import OrcaAgent\n`
    }

    code += `
# Load environment variables
load_dotenv()

def main():
    # Configuration
    # We favor the key provided in the builder UI, then fall back to environment
    api_key = "${apiKeyFromUI}"
    if not api_key or api_key == "undefined":
        api_key = os.getenv("GOOGLE_API_KEY") or os.getenv("GEMINI_API_KEY")
    
    # Initialize tools list (MCP Gateways)
    tools = []\n`

    mcpNodes.forEach(node => {
        if (node.data.url) {
            code += `    tools.append({"name": "${node.data.name || 'mcp_gateway'}", "url": "${node.data.url}"})\n`
        }
    })

    // Gather connected CrewAI tools
    const connectedToolNames: string[] = []

    // Find edges targeting the core node's 'tool' handle
    const toolkitEdges = edges.filter(e => e.target === coreNode.id && e.targetHandle === 'tool')
    toolkitEdges.forEach(te => {
        const toolkitNode = nodes.find(n => n.id === te.source && n.type === 'toolkit')
        if (toolkitNode) {
            // Find tools connected to this toolkit
            const toolEdges = edges.filter(e => e.target === toolkitNode.id)
            toolEdges.forEach(tre => {
                const toolNode = nodes.find(n => n.id === tre.source && n.type === 'crewaiTool')
                if (toolNode && toolNode.data.toolId) {
                    connectedToolNames.push(toolNode.data.toolId)
                }
            })
        }

        // Also allow direct connection from CrewAITool to Agent Core
        const directToolNode = nodes.find(n => n.id === te.source && n.type === 'crewaiTool')
        if (directToolNode && directToolNode.data.toolId) {
            connectedToolNames.push(directToolNode.data.toolId)
        }
    })

    const cdcApiKey = coreNode?.data?.cdcApiKey || ""
    const cdcPrivateKey = coreNode?.data?.cdcPrivateKey || ""

    if (useCryptoComAgent) {
        code += `
    # Initialize the Crypto.com Agent (x402 + CDC Backend)
    agent = CryptoComAgent(
        name="${name}",
        model="${model}",
        vault_address="${vaultAddress}",
        provider_api_key=api_key,
        
        # CDC Configuration (Hardcoded from UI)
        cdc_api_key="${cdcApiKey}" or os.getenv("CDC_API_KEY"),
        cdc_private_key="${cdcPrivateKey}" or os.getenv("CDC_PRIVATE_KEY"),
        
        # Advanced Config
        transfer_limit=${coreNode?.data?.transferLimit ?? -1},
        timeout=${coreNode?.data?.timeout ?? 60},
        
        # Instructions
        instructions="""${systemPrompt}""",
        
        # Custom Tools
        tools=tools + ${JSON.stringify(connectedToolNames)}
    )
    print(f"[{agent.name}] Initialized Crypto.com Agent with {len(agent.tools)} tools.")`
    } else {
        code += `
    # Initialize the Sovereign Agent (Standard)
    agent = OrcaAgent(
        name="${name}",
        model="${model}",
        system_prompt="""${systemPrompt}""",
        price="0.1",
        vault_address="${vaultAddress}",
        api_key=api_key,
        tools=tools + ${JSON.stringify(connectedToolNames)}
    )
    print(f"[{agent.name}] Initialized Sovereign Agent with {len(agent.native_tools) + len(agent.mcps)} tools.")`
    }

    code += `
    
    print(f"[{agent.name}] Local Identity: {agent.vault_address}")
    
    # Start the Server
    # 0rca-deployer expects port 8080 or port from env
    port = int(os.getenv("PORT", 8080))
    agent.run(host="0.0.0.0", port=port)

if __name__ == "__main__":
    main()
`
    return code
}

function extractEnvVars(nodes: any[]) {
    const vars: any[] = []

    // Add essential keys if they exist in nodes
    nodes.forEach(node => {
        // Intelligence & Text Models
        if ((node.type === 'intelligenceModel' || node.type === 'textModel') && node.data.apiKey) {
            vars.push({ key: 'GOOGLE_API_KEY', value: node.data.apiKey })
            vars.push({ key: 'GEMINI_API_KEY', value: node.data.apiKey })
            vars.push({ key: 'OPENAI_API_KEY', value: node.data.apiKey })
        }

        // Crypto.com Agent Keys
        if (node.type === 'cryptoComAgent') {
            if (node.data.apiKey) {
                vars.push({ key: 'GOOGLE_API_KEY', value: node.data.apiKey })
                vars.push({ key: 'GEMINI_API_KEY', value: node.data.apiKey })
            }
            if (node.data.cdcApiKey) vars.push({ key: 'CDC_API_KEY', value: node.data.cdcApiKey })
            if (node.data.cdcPrivateKey) vars.push({ key: 'CDC_PRIVATE_KEY', value: node.data.cdcPrivateKey })
        }

        // Wallet / Identity
        if (node.type === 'wallet' && node.data.privateKey) {
            vars.push({ key: 'AGENT_PRIVATE_KEY', value: node.data.privateKey })
        }
    })

    // Add default 0rca envs
    vars.push({ key: 'ORCA_NETWORK', value: 'mainnet' })

    return vars
}
